//
//  main.cpp
//  M63001151ElaboratoASD
//
//  Created by Michele Maresca on 15/12/20.
//

#include <vector>
#include <time.h>
#include <iostream>
#include <random>
#include <sys/time.h>
#include <iomanip>
#include <numeric>
#include <chrono>


int Left(int index);
int Right(int index);
int Parent(int index);

void heapsort(std::vector<int> &A);
void buildmaxheap(std::vector<int> &A);
void maxheapify(std::vector<int> &A, int heapsize, int index);

void heap_sort(std::vector<int> &A);
int max(std::vector<int> A);
std::vector<int> countingsort(std::vector<int> A, int k);


int main(int argc, const char * argv[]) {
    
    std::cout << std::fixed << std::setprecision(9) << std::left;

 //  Generazione numeri casuali
     std::random_device rd;  //Will be used to obtain a seed for the random number engine
     std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd()
     std::uniform_int_distribution<> distrib(0, 10000);
    
     double tempo0,tempo1,tempo2;
     int Dimensione{100000000};
     std::vector<int> A,D;

    
     //  Generazione Vettore da ordinare
         for(int i=0;i<Dimensione;i++){
             A.push_back(distrib(gen));
         }
    //Use `distrib` to transform the random unsigned int generated by gen into an int in [0, 100]
    
     std::vector<int> B{A};
     std::vector<int> C{A};
         
    auto start0 = std::chrono::steady_clock::now();
    heapsort(A);
    auto stop0 = std::chrono::steady_clock::now();
   
    auto start1 = std::chrono::steady_clock::now();
    heap_sort(B);
    auto stop1 = std::chrono::steady_clock::now();
        
    int k=max(C);
    std::cout<<"K: "<<k<<std::endl;
           
    auto start2 = std::chrono::steady_clock::now();
    D=countingsort(C,k);
    auto stop2 = std::chrono::steady_clock::now();
   
   
    std::chrono::duration<double> duration0 = stop0 - start0;
    std::chrono::duration<double> duration1 = stop1 - start1;
    std::chrono::duration<double> duration2 = stop2 - start2;

   tempo0 = (double)(duration0.count()*1000.0);
   tempo1 = (double)(duration1.count()*1000.0);
   tempo2 = (double)(duration2.count()*1000.0);
    
//    std::cout<<"Tempo di esecuzione HEAPSORT (IMPLEMENTATO): "<<tempo0<<" ms "<<std::endl;
//    std::cout<<"Tempo di esecuzione HEAPSORT (LIBRARY): "<<tempo1<<" ms "<<std::endl;
//    std::cout<<"Tempo di esecuzione COUNTINGSORT (IMPLEMENTATO): "<<tempo2<<" ms "<<std::endl;
    std::cout<<tempo0<<"    "<<tempo1<<"    "<<tempo2<<std::endl;
    std::cout<<std::endl;
    return 0;
}

//  Implementazione funzioni

int Left(int index){
    return index*2;
}

int Right(int index){
    return index*2+1;
}

int Parent(int index){
    return int(index/2);
}

void heapsort(std::vector<int> &A){
    buildmaxheap(A);
    int heapsize=int(A.size());
    for(int i=int(A.size())-1;i>=1;i--){
        int key=A[0];
        A[0]=A[i];
        A[i]=key;
        heapsize=heapsize-1;
        maxheapify(A,heapsize,0);
    }

}

void buildmaxheap(std::vector<int> &A){
    int heapsize=int(A.size());
    for(int i=int((A.size()-1)/2);i>=0;i--){
        maxheapify(A,heapsize,i);
    }
}

void maxheapify(std::vector<int> &A,int heapsize, int index){
    
    int l=Left(index);
    int r=Right(index);
    int largest=index;
    
    if(l<heapsize and A[l]>A[index]){
        largest=l;
    }
    if(r<heapsize and A[r]>A[largest]){
        largest=r;
    }
    if(largest != index){
        int key=A[index];
        A[index]=A[largest];
        A[largest]=key;
        maxheapify(A,heapsize,largest);
    }

}

void heap_sort(std::vector<int> &A){
    make_heap(A.begin(),A.end());
    sort_heap(A.begin(),A.end());
}

std::vector<int> countingsort(std::vector<int> A, int k){
    std::vector<int> B{A};
    int C[k+1];
    for(int i=0;i<=k;i++)
        C[i]=0;
    for(int j=0;j<A.size();j++)
        C[A[j]]=C[A[j]]+1;
//    std::cout<<"Vettore C occorrenze: ";
//    for(auto& x: C){
//        std::cout<<x<<" ";
//    }
//    std::cout<<std::endl;
    for(int i=1;i<=k;i++)
        C[i]=C[i]+C[i-1];
//    std::cout<<"Vettore C somma cumulatica: ";
//    for(auto& x: C){
//        std::cout<<x<<" ";
//    }
//    std::cout<<std::endl;
    for(int j=A.size()-1;j>=0;j--){
        B[C[A[j]]-1]=A[j];
//        std::cout<<B[C[A[j]]-1]<<std::endl;
        C[A[j]]=C[A[j]]-1;
    }
    return B;
}

int max(std::vector<int> A){
   int max=0;
    for(auto& x: A){
        if(x>max)
            max=x;
    }
    return max;
}
